{"version":3,"sources":["typedarray.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"typedarray.js","sourcesContent":["/*\n Copyright (c) 2010, Linden Research, Inc.\n Copyright (c) 2014, Joshua Bell\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n $/LicenseInfo$\n */\n\n// Original can be found at:\n//   https://bitbucket.org/lindenlab/llsd\n// Modifications by Joshua Bell inexorabletash@gmail.com\n//   https://github.com/inexorabletash/polyfill\n\n// ES3/ES5 implementation of the Krhonos Typed Array Specification\n//   Ref: http://www.khronos.org/registry/typedarray/specs/latest/\n//   Date: 2011-02-01\n//\n// Variations:\n//  * Allows typed_array.get/set() as alias for subscripts (typed_array[])\n//  * Gradually migrating structure from Khronos spec to ES6 spec\n(function(global) {\n  'use strict';\n  var undefined = (void 0); // Paranoia\n\n  // Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to\n  // create, and consume so much memory, that the browser appears frozen.\n  var MAX_ARRAY_LENGTH = 1e5;\n\n  // Approximations of internal ECMAScript conversion functions\n  function Type(v) {\n    switch(typeof v) {\n    case 'undefined': return 'undefined';\n    case 'boolean': return 'boolean';\n    case 'number': return 'number';\n    case 'string': return 'string';\n    default: return v === null ? 'null' : 'object';\n    }\n  }\n\n  // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:\n  function Class(v) { return Object.prototype.toString.call(v).replace(/^\\[object *|\\]$/g, ''); }\n  function IsCallable(o) { return typeof o === 'function'; }\n  function ToObject(v) {\n    if (v === null || v === undefined) throw TypeError();\n    return Object(v);\n  }\n  function ToInt32(v) { return v >> 0; }\n  function ToUint32(v) { return v >>> 0; }\n\n  // Snapshot intrinsics\n  var LN2 = Math.LN2,\n      abs = Math.abs,\n      floor = Math.floor,\n      log = Math.log,\n      max = Math.max,\n      min = Math.min,\n      pow = Math.pow,\n      round = Math.round;\n\n  // emulate ES5 getter/setter API using legacy APIs\n  // http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx\n  // (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but\n  // note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)\n\n  (function() {\n    var orig = Object.defineProperty;\n    var dom_only = !(function(){try{return Object.defineProperty({},'x',{});}catch(_){return false;}}());\n\n    if (!orig || dom_only) {\n      Object.defineProperty = function (o, prop, desc) {\n        // In IE8 try built-in implementation for defining properties on DOM prototypes.\n        if (orig)\n          try { return orig(o, prop, desc); } catch (_) {}\n        if (o !== Object(o))\n          throw TypeError('Object.defineProperty called on non-object');\n        if (Object.prototype.__defineGetter__ && ('get' in desc))\n          Object.prototype.__defineGetter__.call(o, prop, desc.get);\n        if (Object.prototype.__defineSetter__ && ('set' in desc))\n          Object.prototype.__defineSetter__.call(o, prop, desc.set);\n        if ('value' in desc)\n          o[prop] = desc.value;\n        return o;\n      };\n    }\n  }());\n\n  // ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)\n  // for index in 0 ... obj.length\n  function makeArrayAccessors(obj) {\n    if (obj.length > MAX_ARRAY_LENGTH) throw RangeError('Array too large for polyfill');\n\n    function makeArrayAccessor(index) {\n      Object.defineProperty(obj, index, {\n        'get': function() { return obj._getter(index); },\n        'set': function(v) { obj._setter(index, v); },\n        enumerable: true,\n        configurable: false\n      });\n    }\n\n    var i;\n    for (i = 0; i < obj.length; i += 1) {\n      makeArrayAccessor(i);\n    }\n  }\n\n  // Internal conversion functions:\n  //    pack<Type>()   - take a number (interpreted as Type), output a byte array\n  //    unpack<Type>() - take a byte array, output a Type-like number\n\n  function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }\n  function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }\n\n  function packI8(n) { return [n & 0xff]; }\n  function unpackI8(bytes) { return as_signed(bytes[0], 8); }\n\n  function packU8(n) { return [n & 0xff]; }\n  function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }\n\n  function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }\n\n  function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\n  function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }\n\n  function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\n  function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }\n\n  function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\n  function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\n  function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\n  function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\n  function packIEEE754(v, ebits, fbits) {\n\n    var bias = (1 << (ebits - 1)) - 1,\n        s, e, f, ln,\n        i, bits, str, bytes;\n\n    function roundToEven(n) {\n      var w = floor(n), f = n - w;\n      if (f < 0.5)\n        return w;\n      if (f > 0.5)\n        return w + 1;\n      return w % 2 ? w + 1 : w;\n    }\n\n    // Compute sign, exponent, fraction\n    if (v !== v) {\n      // NaN\n      // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n      e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;\n    } else if (v === Infinity || v === -Infinity) {\n      e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;\n    } else if (v === 0) {\n      e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;\n    } else {\n      s = v < 0;\n      v = abs(v);\n\n      if (v >= pow(2, 1 - bias)) {\n        e = min(floor(log(v) / LN2), 1023);\n        f = roundToEven(v / pow(2, e) * pow(2, fbits));\n        if (f / pow(2, fbits) >= 2) {\n          e = e + 1;\n          f = 1;\n        }\n        if (e > bias) {\n          // Overflow\n          e = (1 << ebits) - 1;\n          f = 0;\n        } else {\n          // Normalized\n          e = e + bias;\n          f = f - pow(2, fbits);\n        }\n      } else {\n        // Denormalized\n        e = 0;\n        f = roundToEven(v / pow(2, 1 - bias - fbits));\n      }\n    }\n\n    // Pack sign, exponent, fraction\n    bits = [];\n    for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }\n    for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }\n    bits.push(s ? 1 : 0);\n    bits.reverse();\n    str = bits.join('');\n\n    // Bits to bytes\n    bytes = [];\n    while (str.length) {\n      bytes.push(parseInt(str.substring(0, 8), 2));\n      str = str.substring(8);\n    }\n    return bytes;\n  }\n\n  function unpackIEEE754(bytes, ebits, fbits) {\n    // Bytes to bits\n    var bits = [], i, j, b, str,\n        bias, s, e, f;\n\n    for (i = bytes.length; i; i -= 1) {\n      b = bytes[i - 1];\n      for (j = 8; j; j -= 1) {\n        bits.push(b % 2 ? 1 : 0); b = b >> 1;\n      }\n    }\n    bits.reverse();\n    str = bits.join('');\n\n    // Unpack sign, exponent, fraction\n    bias = (1 << (ebits - 1)) - 1;\n    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n    e = parseInt(str.substring(1, 1 + ebits), 2);\n    f = parseInt(str.substring(1 + ebits), 2);\n\n    // Produce number\n    if (e === (1 << ebits) - 1) {\n      return f !== 0 ? NaN : s * Infinity;\n    } else if (e > 0) {\n      // Normalized\n      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n    } else if (f !== 0) {\n      // Denormalized\n      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n    } else {\n      return s < 0 ? -0 : 0;\n    }\n  }\n\n  function unpackF64(b) { return unpackIEEE754(b, 11, 52); }\n  function packF64(v) { return packIEEE754(v, 11, 52); }\n  function unpackF32(b) { return unpackIEEE754(b, 8, 23); }\n  function packF32(v) { return packIEEE754(v, 8, 23); }\n\n  //\n  // 3 The ArrayBuffer Type\n  //\n\n  (function() {\n\n    function ArrayBuffer(length) {\n      length = ToInt32(length);\n      if (length < 0) throw RangeError('ArrayBuffer size is not a small enough positive integer.');\n      Object.defineProperty(this, 'byteLength', {value: length});\n      Object.defineProperty(this, '_bytes', {value: Array(length)});\n\n      for (var i = 0; i < length; i += 1)\n        this._bytes[i] = 0;\n    }\n\n    global.ArrayBuffer = global.ArrayBuffer || ArrayBuffer;\n\n    //\n    // 5 The Typed Array View Types\n    //\n\n    function $TypedArray$() {\n\n      // %TypedArray% ( length )\n      if (!arguments.length || typeof arguments[0] !== 'object') {\n        return (function(length) {\n          length = ToInt32(length);\n          if (length < 0) throw RangeError('length is not a small enough positive integer.');\n          Object.defineProperty(this, 'length', {value: length});\n          Object.defineProperty(this, 'byteLength', {value: length * this.BYTES_PER_ELEMENT});\n          Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(this.byteLength)});\n          Object.defineProperty(this, 'byteOffset', {value: 0});\n\n         }).apply(this, arguments);\n      }\n\n      // %TypedArray% ( typedArray )\n      if (arguments.length >= 1 &&\n          Type(arguments[0]) === 'object' &&\n          arguments[0] instanceof $TypedArray$) {\n        return (function(typedArray){\n          if (this.constructor !== typedArray.constructor) throw TypeError();\n\n          var byteLength = typedArray.length * this.BYTES_PER_ELEMENT;\n          Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});\n          Object.defineProperty(this, 'byteLength', {value: byteLength});\n          Object.defineProperty(this, 'byteOffset', {value: 0});\n          Object.defineProperty(this, 'length', {value: typedArray.length});\n\n          for (var i = 0; i < this.length; i += 1)\n            this._setter(i, typedArray._getter(i));\n\n        }).apply(this, arguments);\n      }\n\n      // %TypedArray% ( array )\n      if (arguments.length >= 1 &&\n          Type(arguments[0]) === 'object' &&\n          !(arguments[0] instanceof $TypedArray$) &&\n          !(arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {\n        return (function(array) {\n\n          var byteLength = array.length * this.BYTES_PER_ELEMENT;\n          Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});\n          Object.defineProperty(this, 'byteLength', {value: byteLength});\n          Object.defineProperty(this, 'byteOffset', {value: 0});\n          Object.defineProperty(this, 'length', {value: array.length});\n\n          for (var i = 0; i < this.length; i += 1) {\n            var s = array[i];\n            this._setter(i, Number(s));\n          }\n        }).apply(this, arguments);\n      }\n\n      // %TypedArray% ( buffer, byteOffset=0, length=undefined )\n      if (arguments.length >= 1 &&\n          Type(arguments[0]) === 'object' &&\n          (arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {\n        return (function(buffer, byteOffset, length) {\n\n          byteOffset = ToUint32(byteOffset);\n          if (byteOffset > buffer.byteLength)\n            throw RangeError('byteOffset out of range');\n\n          // The given byteOffset must be a multiple of the element\n          // size of the specific type, otherwise an exception is raised.\n          if (byteOffset % this.BYTES_PER_ELEMENT)\n            throw RangeError('buffer length minus the byteOffset is not a multiple of the element size.');\n\n          if (length === undefined) {\n            var byteLength = buffer.byteLength - byteOffset;\n            if (byteLength % this.BYTES_PER_ELEMENT)\n              throw RangeError('length of buffer minus byteOffset not a multiple of the element size');\n            length = byteLength / this.BYTES_PER_ELEMENT;\n\n          } else {\n            length = ToUint32(length);\n            byteLength = length * this.BYTES_PER_ELEMENT;\n          }\n\n          if ((byteOffset + byteLength) > buffer.byteLength)\n            throw RangeError('byteOffset and length reference an area beyond the end of the buffer');\n\n          Object.defineProperty(this, 'buffer', {value: buffer});\n          Object.defineProperty(this, 'byteLength', {value: byteLength});\n          Object.defineProperty(this, 'byteOffset', {value: byteOffset});\n          Object.defineProperty(this, 'length', {value: length});\n\n        }).apply(this, arguments);\n      }\n\n      // %TypedArray% ( all other argument combinations )\n      throw TypeError();\n    }\n\n    // Properties of the %TypedArray Instrinsic Object\n\n    // %TypedArray%.from ( source , mapfn=undefined, thisArg=undefined )\n    Object.defineProperty($TypedArray$, 'from', {value: function(iterable) {\n      return new this(iterable);\n    }});\n\n    // %TypedArray%.of ( ...items )\n    Object.defineProperty($TypedArray$, 'of', {value: function(/*...items*/) {\n      return new this(arguments);\n    }});\n\n    // %TypedArray%.prototype\n    var $TypedArrayPrototype$ = {};\n    $TypedArray$.prototype = $TypedArrayPrototype$;\n\n    // WebIDL: getter type (unsigned long index);\n    Object.defineProperty($TypedArray$.prototype, '_getter', {value: function(index) {\n      if (arguments.length < 1) throw SyntaxError('Not enough arguments');\n\n      index = ToUint32(index);\n      if (index >= this.length)\n        return undefined;\n\n      var bytes = [], i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        bytes.push(this.buffer._bytes[o]);\n      }\n      return this._unpack(bytes);\n    }});\n\n    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);\n    Object.defineProperty($TypedArray$.prototype, 'get', {value: $TypedArray$.prototype._getter});\n\n    // WebIDL: setter void (unsigned long index, type value);\n    Object.defineProperty($TypedArray$.prototype, '_setter', {value: function(index, value) {\n      if (arguments.length < 2) throw SyntaxError('Not enough arguments');\n\n      index = ToUint32(index);\n      if (index >= this.length)\n        return;\n\n      var bytes = this._pack(value), i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        this.buffer._bytes[o] = bytes[i];\n      }\n    }});\n\n    // get %TypedArray%.prototype.buffer\n    // get %TypedArray%.prototype.byteLength\n    // get %TypedArray%.prototype.byteOffset\n    // -- applied directly to the object in the constructor\n\n    // %TypedArray%.prototype.constructor\n    Object.defineProperty($TypedArray$.prototype, 'constructor', {value: $TypedArray$});\n\n    // %TypedArray%.prototype.copyWithin (target, start, end = this.length )\n    Object.defineProperty($TypedArray$.prototype, 'copyWithin', {value: function(target, start) {\n      var end = arguments[2];\n\n      var o = ToObject(this);\n      var lenVal = o.length;\n      var len = ToUint32(lenVal);\n      len = max(len, 0);\n      var relativeTarget = ToInt32(target);\n      var to;\n      if (relativeTarget < 0)\n        to = max(len + relativeTarget, 0);\n      else\n        to = min(relativeTarget, len);\n      var relativeStart = ToInt32(start);\n      var from;\n      if (relativeStart < 0)\n        from = max(len + relativeStart, 0);\n      else\n        from = min(relativeStart, len);\n      var relativeEnd;\n      if (end === undefined)\n        relativeEnd = len;\n      else\n        relativeEnd = ToInt32(end);\n      var final;\n      if (relativeEnd < 0)\n        final = max(len + relativeEnd, 0);\n      else\n        final = min(relativeEnd, len);\n      var count = min(final - from, len - to);\n      var direction;\n      if (from < to && to < from + count) {\n        direction = -1;\n        from = from + count - 1;\n        to = to + count - 1;\n      } else {\n        direction = 1;\n      }\n      while (count > 0) {\n        o._setter(to, o._getter(from));\n        from = from + direction;\n        to = to + direction;\n        count = count - 1;\n      }\n      return o;\n    }});\n\n    // %TypedArray%.prototype.entries ( )\n    // -- defined in es6.js to shim browsers w/ native TypedArrays\n\n    // %TypedArray%.prototype.every ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, 'every', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var thisArg = arguments[1];\n      for (var i = 0; i < len; i++) {\n        if (!callbackfn.call(thisArg, t._getter(i), i, t))\n          return false;\n      }\n      return true;\n    }});\n\n    // %TypedArray%.prototype.fill (value, start = 0, end = this.length )\n    Object.defineProperty($TypedArray$.prototype, 'fill', {value: function(value) {\n      var start = arguments[1],\n          end = arguments[2];\n\n      var o = ToObject(this);\n      var lenVal = o.length;\n      var len = ToUint32(lenVal);\n      len = max(len, 0);\n      var relativeStart = ToInt32(start);\n      var k;\n      if (relativeStart < 0)\n        k = max((len + relativeStart), 0);\n      else\n        k = min(relativeStart, len);\n      var relativeEnd;\n      if (end === undefined)\n        relativeEnd = len;\n      else\n        relativeEnd = ToInt32(end);\n      var final;\n      if (relativeEnd < 0)\n        final = max((len + relativeEnd), 0);\n      else\n        final = min(relativeEnd, len);\n      while (k < final) {\n        o._setter(k, value);\n        k += 1;\n      }\n      return o;\n    }});\n\n    // %TypedArray%.prototype.filter ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, 'filter', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var res = [];\n      var thisp = arguments[1];\n      for (var i = 0; i < len; i++) {\n        var val = t._getter(i); // in case fun mutates this\n        if (callbackfn.call(thisp, val, i, t))\n          res.push(val);\n      }\n      return new this.constructor(res);\n    }});\n\n    // %TypedArray%.prototype.find (predicate, thisArg = undefined)\n    Object.defineProperty($TypedArray$.prototype, 'find', {value: function(predicate) {\n      var o = ToObject(this);\n      var lenValue = o.length;\n      var len = ToUint32(lenValue);\n      if (!IsCallable(predicate)) throw TypeError();\n      var t = arguments.length > 1 ? arguments[1] : undefined;\n      var k = 0;\n      while (k < len) {\n        var kValue = o._getter(k);\n        var testResult = predicate.call(t, kValue, k, o);\n        if (Boolean(testResult))\n          return kValue;\n        ++k;\n      }\n      return undefined;\n    }});\n\n    // %TypedArray%.prototype.findIndex ( predicate, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, 'findIndex', {value: function(predicate) {\n      var o = ToObject(this);\n      var lenValue = o.length;\n      var len = ToUint32(lenValue);\n      if (!IsCallable(predicate)) throw TypeError();\n      var t = arguments.length > 1 ? arguments[1] : undefined;\n      var k = 0;\n      while (k < len) {\n        var kValue = o._getter(k);\n        var testResult = predicate.call(t, kValue, k, o);\n        if (Boolean(testResult))\n          return k;\n        ++k;\n      }\n      return -1;\n    }});\n\n    // %TypedArray%.prototype.forEach ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, 'forEach', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var thisp = arguments[1];\n      for (var i = 0; i < len; i++)\n        callbackfn.call(thisp, t._getter(i), i, t);\n    }});\n\n    // %TypedArray%.prototype.indexOf (searchElement, fromIndex = 0 )\n    Object.defineProperty($TypedArray$.prototype, 'indexOf', {value: function(searchElement) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (len === 0) return -1;\n      var n = 0;\n      if (arguments.length > 0) {\n        n = Number(arguments[1]);\n        if (n !== n) {\n          n = 0;\n        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n          n = (n > 0 || -1) * floor(abs(n));\n        }\n      }\n      if (n >= len) return -1;\n      var k = n >= 0 ? n : max(len - abs(n), 0);\n      for (; k < len; k++) {\n        if (t._getter(k) === searchElement) {\n          return k;\n        }\n      }\n      return -1;\n    }});\n\n    // %TypedArray%.prototype.join ( separator )\n    Object.defineProperty($TypedArray$.prototype, 'join', {value: function(separator) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      var tmp = Array(len);\n      for (var i = 0; i < len; ++i)\n        tmp[i] = t._getter(i);\n      return tmp.join(separator === undefined ? ',' : separator); // Hack for IE7\n    }});\n\n    // %TypedArray%.prototype.keys ( )\n    // -- defined in es6.js to shim browsers w/ native TypedArrays\n\n    // %TypedArray%.prototype.lastIndexOf ( searchElement, fromIndex = this.length-1 )\n    Object.defineProperty($TypedArray$.prototype, 'lastIndexOf', {value: function(searchElement) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (len === 0) return -1;\n      var n = len;\n      if (arguments.length > 1) {\n        n = Number(arguments[1]);\n        if (n !== n) {\n          n = 0;\n        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n          n = (n > 0 || -1) * floor(abs(n));\n        }\n      }\n      var k = n >= 0 ? min(n, len - 1) : len - abs(n);\n      for (; k >= 0; k--) {\n        if (t._getter(k) === searchElement)\n          return k;\n      }\n      return -1;\n    }});\n\n    // get %TypedArray%.prototype.length\n    // -- applied directly to the object in the constructor\n\n    // %TypedArray%.prototype.map ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, 'map', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var res = []; res.length = len;\n      var thisp = arguments[1];\n      for (var i = 0; i < len; i++)\n        res[i] = callbackfn.call(thisp, t._getter(i), i, t);\n      return new this.constructor(res);\n    }});\n\n    // %TypedArray%.prototype.reduce ( callbackfn [, initialValue] )\n    Object.defineProperty($TypedArray$.prototype, 'reduce', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      // no value to return if no initial value and an empty array\n      if (len === 0 && arguments.length === 1) throw TypeError();\n      var k = 0;\n      var accumulator;\n      if (arguments.length >= 2) {\n        accumulator = arguments[1];\n      } else {\n        accumulator = t._getter(k++);\n      }\n      while (k < len) {\n        accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);\n        k++;\n      }\n      return accumulator;\n    }});\n\n    // %TypedArray%.prototype.reduceRight ( callbackfn [, initialValue] )\n    Object.defineProperty($TypedArray$.prototype, 'reduceRight', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      // no value to return if no initial value, empty array\n      if (len === 0 && arguments.length === 1) throw TypeError();\n      var k = len - 1;\n      var accumulator;\n      if (arguments.length >= 2) {\n        accumulator = arguments[1];\n      } else {\n        accumulator = t._getter(k--);\n      }\n      while (k >= 0) {\n        accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);\n        k--;\n      }\n      return accumulator;\n    }});\n\n    // %TypedArray%.prototype.reverse ( )\n    Object.defineProperty($TypedArray$.prototype, 'reverse', {value: function() {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      var half = floor(len / 2);\n      for (var i = 0, j = len - 1; i < half; ++i, --j) {\n        var tmp = t._getter(i);\n        t._setter(i, t._getter(j));\n        t._setter(j, tmp);\n      }\n      return t;\n    }});\n\n    // %TypedArray%.prototype.set(array, offset = 0 )\n    // %TypedArray%.prototype.set(typedArray, offset = 0 )\n    // WebIDL: void set(TypedArray array, optional unsigned long offset);\n    // WebIDL: void set(sequence<type> array, optional unsigned long offset);\n    Object.defineProperty($TypedArray$.prototype, 'set', {value: function(index, value) {\n      if (arguments.length < 1) throw SyntaxError('Not enough arguments');\n      var array, sequence, offset, len,\n          i, s, d,\n          byteOffset, byteLength, tmp;\n\n      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {\n        // void set(TypedArray array, optional unsigned long offset);\n        array = arguments[0];\n        offset = ToUint32(arguments[1]);\n\n        if (offset + array.length > this.length) {\n          throw RangeError('Offset plus length of array is out of range');\n        }\n\n        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;\n        byteLength = array.length * this.BYTES_PER_ELEMENT;\n\n        if (array.buffer === this.buffer) {\n          tmp = [];\n          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {\n            tmp[i] = array.buffer._bytes[s];\n          }\n          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {\n            this.buffer._bytes[d] = tmp[i];\n          }\n        } else {\n          for (i = 0, s = array.byteOffset, d = byteOffset;\n               i < byteLength; i += 1, s += 1, d += 1) {\n            this.buffer._bytes[d] = array.buffer._bytes[s];\n          }\n        }\n      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {\n        // void set(sequence<type> array, optional unsigned long offset);\n        sequence = arguments[0];\n        len = ToUint32(sequence.length);\n        offset = ToUint32(arguments[1]);\n\n        if (offset + len > this.length) {\n          throw RangeError('Offset plus length of array is out of range');\n        }\n\n        for (i = 0; i < len; i += 1) {\n          s = sequence[i];\n          this._setter(offset + i, Number(s));\n        }\n      } else {\n        throw TypeError('Unexpected argument type(s)');\n      }\n    }});\n\n    // %TypedArray%.prototype.slice ( start, end )\n    Object.defineProperty($TypedArray$.prototype, 'slice', {value: function(start, end) {\n      var o = ToObject(this);\n      var lenVal = o.length;\n      var len = ToUint32(lenVal);\n      var relativeStart = ToInt32(start);\n      var k = (relativeStart < 0) ? max(len + relativeStart, 0) : min(relativeStart, len);\n      var relativeEnd = (end === undefined) ? len : ToInt32(end);\n      var final = (relativeEnd < 0) ? max(len + relativeEnd, 0) : min(relativeEnd, len);\n      var count = final - k;\n      var c = o.constructor;\n      var a = new c(count);\n      var n = 0;\n      while (k < final) {\n        var kValue = o._getter(k);\n        a._setter(n, kValue);\n        ++k;\n        ++n;\n      }\n      return a;\n    }});\n\n    // %TypedArray%.prototype.some ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, 'some', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var thisp = arguments[1];\n      for (var i = 0; i < len; i++) {\n        if (callbackfn.call(thisp, t._getter(i), i, t)) {\n          return true;\n        }\n      }\n      return false;\n    }});\n\n    // %TypedArray%.prototype.sort ( comparefn )\n    Object.defineProperty($TypedArray$.prototype, 'sort', {value: function(comparefn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      var tmp = Array(len);\n      for (var i = 0; i < len; ++i)\n        tmp[i] = t._getter(i);\n      if (comparefn) tmp.sort(comparefn); else tmp.sort(); // Hack for IE8/9\n      for (i = 0; i < len; ++i)\n        t._setter(i, tmp[i]);\n      return t;\n    }});\n\n    // %TypedArray%.prototype.subarray(begin = 0, end = this.length )\n    // WebIDL: TypedArray subarray(long begin, optional long end);\n    Object.defineProperty($TypedArray$.prototype, 'subarray', {value: function(start, end) {\n      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n      start = ToInt32(start);\n      end = ToInt32(end);\n\n      if (arguments.length < 1) { start = 0; }\n      if (arguments.length < 2) { end = this.length; }\n\n      if (start < 0) { start = this.length + start; }\n      if (end < 0) { end = this.length + end; }\n\n      start = clamp(start, 0, this.length);\n      end = clamp(end, 0, this.length);\n\n      var len = end - start;\n      if (len < 0) {\n        len = 0;\n      }\n\n      return new this.constructor(\n        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n    }});\n\n    // %TypedArray%.prototype.toLocaleString ( )\n    // %TypedArray%.prototype.toString ( )\n    // %TypedArray%.prototype.values ( )\n    // %TypedArray%.prototype [ @@iterator ] ( )\n    // get %TypedArray%.prototype [ @@toStringTag ]\n    // -- defined in es6.js to shim browsers w/ native TypedArrays\n\n    function makeTypedArray(elementSize, pack, unpack) {\n      // Each TypedArray type requires a distinct constructor instance with\n      // identical logic, which this produces.\n      var TypedArray = function() {\n        Object.defineProperty(this, 'constructor', {value: TypedArray});\n        $TypedArray$.apply(this, arguments);\n        makeArrayAccessors(this);\n      };\n      if ('__proto__' in TypedArray) {\n        TypedArray.__proto__ = $TypedArray$;\n      } else {\n        TypedArray.from = $TypedArray$.from;\n        TypedArray.of = $TypedArray$.of;\n      }\n\n      TypedArray.BYTES_PER_ELEMENT = elementSize;\n\n      var TypedArrayPrototype = function() {};\n      TypedArrayPrototype.prototype = $TypedArrayPrototype$;\n\n      TypedArray.prototype = new TypedArrayPrototype();\n\n      Object.defineProperty(TypedArray.prototype, 'BYTES_PER_ELEMENT', {value: elementSize});\n      Object.defineProperty(TypedArray.prototype, '_pack', {value: pack});\n      Object.defineProperty(TypedArray.prototype, '_unpack', {value: unpack});\n\n      return TypedArray;\n    }\n\n    var Int8Array = makeTypedArray(1, packI8, unpackI8);\n    var Uint8Array = makeTypedArray(1, packU8, unpackU8);\n    var Uint8ClampedArray = makeTypedArray(1, packU8Clamped, unpackU8);\n    var Int16Array = makeTypedArray(2, packI16, unpackI16);\n    var Uint16Array = makeTypedArray(2, packU16, unpackU16);\n    var Int32Array = makeTypedArray(4, packI32, unpackI32);\n    var Uint32Array = makeTypedArray(4, packU32, unpackU32);\n    var Float32Array = makeTypedArray(4, packF32, unpackF32);\n    var Float64Array = makeTypedArray(8, packF64, unpackF64);\n\n    global.Int8Array = global.Int8Array || Int8Array;\n    global.Uint8Array = global.Uint8Array || Uint8Array;\n    global.Uint8ClampedArray = global.Uint8ClampedArray || Uint8ClampedArray;\n    global.Int16Array = global.Int16Array || Int16Array;\n    global.Uint16Array = global.Uint16Array || Uint16Array;\n    global.Int32Array = global.Int32Array || Int32Array;\n    global.Uint32Array = global.Uint32Array || Uint32Array;\n    global.Float32Array = global.Float32Array || Float32Array;\n    global.Float64Array = global.Float64Array || Float64Array;\n  }());\n\n  //\n  // 6 The DataView View Type\n  //\n\n  (function() {\n    function r(array, index) {\n      return IsCallable(array.get) ? array.get(index) : array[index];\n    }\n\n    var IS_BIG_ENDIAN = (function() {\n      var u16array = new Uint16Array([0x1234]),\n          u8array = new Uint8Array(u16array.buffer);\n      return r(u8array, 0) === 0x12;\n    }());\n\n    // DataView(buffer, byteOffset=0, byteLength=undefined)\n    // WebIDL: Constructor(ArrayBuffer buffer,\n    //                     optional unsigned long byteOffset,\n    //                     optional unsigned long byteLength)\n    function DataView(buffer, byteOffset, byteLength) {\n      if (!(buffer instanceof ArrayBuffer || Class(buffer) === 'ArrayBuffer')) throw TypeError();\n\n      byteOffset = ToUint32(byteOffset);\n      if (byteOffset > buffer.byteLength)\n        throw RangeError('byteOffset out of range');\n\n      if (byteLength === undefined)\n        byteLength = buffer.byteLength - byteOffset;\n      else\n        byteLength = ToUint32(byteLength);\n\n      if ((byteOffset + byteLength) > buffer.byteLength)\n        throw RangeError('byteOffset and length reference an area beyond the end of the buffer');\n\n      Object.defineProperty(this, 'buffer', {value: buffer});\n      Object.defineProperty(this, 'byteLength', {value: byteLength});\n      Object.defineProperty(this, 'byteOffset', {value: byteOffset});\n    };\n\n    // get DataView.prototype.buffer\n    // get DataView.prototype.byteLength\n    // get DataView.prototype.byteOffset\n    // -- applied directly to instances by the constructor\n\n    function makeGetter(arrayType) {\n      return function GetViewValue(byteOffset, littleEndian) {\n        byteOffset = ToUint32(byteOffset);\n\n        if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)\n          throw RangeError('Array index out of range');\n\n        byteOffset += this.byteOffset;\n\n        var uint8Array = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),\n            bytes = [];\n        for (var i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)\n          bytes.push(r(uint8Array, i));\n\n        if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))\n          bytes.reverse();\n\n        return r(new arrayType(new Uint8Array(bytes).buffer), 0);\n      };\n    }\n\n    Object.defineProperty(DataView.prototype, 'getUint8', {value: makeGetter(Uint8Array)});\n    Object.defineProperty(DataView.prototype, 'getInt8', {value: makeGetter(Int8Array)});\n    Object.defineProperty(DataView.prototype, 'getUint16', {value: makeGetter(Uint16Array)});\n    Object.defineProperty(DataView.prototype, 'getInt16', {value: makeGetter(Int16Array)});\n    Object.defineProperty(DataView.prototype, 'getUint32', {value: makeGetter(Uint32Array)});\n    Object.defineProperty(DataView.prototype, 'getInt32', {value: makeGetter(Int32Array)});\n    Object.defineProperty(DataView.prototype, 'getFloat32', {value: makeGetter(Float32Array)});\n    Object.defineProperty(DataView.prototype, 'getFloat64', {value: makeGetter(Float64Array)});\n\n    function makeSetter(arrayType) {\n      return function SetViewValue(byteOffset, value, littleEndian) {\n        byteOffset = ToUint32(byteOffset);\n        if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)\n          throw RangeError('Array index out of range');\n\n        // Get bytes\n        var typeArray = new arrayType([value]),\n            byteArray = new Uint8Array(typeArray.buffer),\n            bytes = [], i, byteView;\n\n        for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)\n          bytes.push(r(byteArray, i));\n\n        // Flip if necessary\n        if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))\n          bytes.reverse();\n\n        // Write them\n        byteView = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);\n        byteView.set(bytes);\n      };\n    }\n\n    Object.defineProperty(DataView.prototype, 'setUint8', {value: makeSetter(Uint8Array)});\n    Object.defineProperty(DataView.prototype, 'setInt8', {value: makeSetter(Int8Array)});\n    Object.defineProperty(DataView.prototype, 'setUint16', {value: makeSetter(Uint16Array)});\n    Object.defineProperty(DataView.prototype, 'setInt16', {value: makeSetter(Int16Array)});\n    Object.defineProperty(DataView.prototype, 'setUint32', {value: makeSetter(Uint32Array)});\n    Object.defineProperty(DataView.prototype, 'setInt32', {value: makeSetter(Int32Array)});\n    Object.defineProperty(DataView.prototype, 'setFloat32', {value: makeSetter(Float32Array)});\n    Object.defineProperty(DataView.prototype, 'setFloat64', {value: makeSetter(Float64Array)});\n\n    global.DataView = global.DataView || DataView;\n\n  }());\n\n}(this));\n"],"sourceRoot":"/source/"}